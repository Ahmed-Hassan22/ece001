<!doctype html>
<html>
<Head>
<Title>Types</title>
</Head>
<body>
<button/> <A href="Main Page.HTML"> Home Pagege </button>
<ul>
<li><a href="#Trditional Programming Language">Trditional Programming Language</a></li>
<li><a href="#Event Drevin Programming Language">Event Drevin Programming Language</a></li>
<li><a href="#low-level Programming Language">low-level Programming Language</a></li>
<li><a href="#High-level Programming Language">High-level Programming Language</a></li>
<li><a href="#Very High-level Programming Language">Very High-level Programming Language</a></li>

</ul>
<br/>
<Div id="Trditional Programming Language"> 
<h1 style="color:Tomato;"><u><strong> About Trditional Programming Language</strong></u></h1>
<style>
h1 {text-align: center;}
</style>
<p>Every software program is written in a programming language, and there are several languages for every major
 CPU series; typically an assembly language and a number of high-level languages. Assembly languages are machine 
 specific, and the machine language they generate runs on only one CPU family. Unless the machine 
 languages are very similar, it is difficult to translate an assembly language program from one CPU series
 into another. See standards - machine languages.
The high-level programming language was created to eliminate machine dependency. Languages such as COBOL, FORTRAN,
 BASIC and C were designed to run on many different computers. However, compatibility has always been an issue. By 
 the time a new language feature becomes a standard, a dozen new features have been already implemented. For example,
 in the early 1980s, dBASE became a de facto standard business programming language. Soon after, dBASE spawned Clipper, 
 QuickSilver, Force III, dbXL, Foxbase and FoxPro, all competitive products and all incomplete versions of dBASE. 
 None of them provided every dBASE command, and they all provided features not found in dBASE.
There is no rule of thumb for translating one dialect of a programming language into another. The job may be difficult
 or easy. At times, software is written to translate one dialect into another, as well as one programming language into
 another. If the translation program cannot translate the program entirely, then manual tailoring 
 is necessary. In these cases, it is often easier to rewrite the program from scratch.
Compatibility can be achieved when a programming language conforms to the ANSI (American National Standards Institute)
 standard for that language. For example, if the same version of an ANSI COBOL compiler is available for two different CPUs,
 a program written in ANSI COBOL can usually be compiled into each of the two machine environments without requiring any 
 changes in the code.
Beyond traditional programming languages such as COBOL, C/C++, known as third-generation languages,
 or 3GLs, there are more than a hundred software environments used to develop applications for LANs and 
 the Web (see client/server development system). Each of them attempts to provide less programming-like and
 more English-like syntax (see fourth-generation language).
Visual development tools are also available for building the graphical user interface by
 "drawing" the screen and dragging and dropping symbols on it. Some languages allow predefined
 data processing actions to be dragged and dropped as well, eliminating the tedium of writing program code. 
 All these software-building tools produce even more standards, and the programming pool has become increasingly
 fragmented. See programming language and standards.
</p>
</div>
<hr/>
<Div id="Event Drevin Programming Language"> 
<h1 style="color:Tomato;"><u><strong> About Event Drevin Programming Language</strong></u></h1>
<p>In computer programming, event-driven programming is a programming paradigm in which the flow 
of the program is determined by events such as user actions (mouse clicks, key presses), sensor outputs,
 or messages from other programs or threads. Event-driven programming is the dominant paradigm used in graphical 
 user interfaces and other applications (e.g., JavaScript web applications) that are centered on performing certain 
 actions in response to user input. This is also true of programming for device drivers (e.g., P in USB device driver
 stacks
In an event-driven application, there is generally a main loop that listens for events, and then triggers a callback 
function when one of those events is detected. In embedded systems, the same may be achieved using hardware interrupts
 instead of a constantly running main loop. Event-driven programs can be written in any programming language, although
 the task is easier in languages that provide high-level abstractions, such as await and closures.
 The first step in developing an event-driven program is to write a series of subroutines, or methods, called event-handler
 routines. These routines handle the events to which the main program will respond. For example, a single left-button
 mouse-click on a command button in a GUI program may trigger a routine that will open another window, save data to 
 a database or exit the application. Many modern-day programming environments provide the programmer with event 
 templates, allowing the programmer to focus on writing the event code.

The second step is to bind event handlers to events so that the correct function is called when the 
event takes place. Graphical editors combine the first two steps: double-click on a button, and the
 editor creates an (empty) event handler associated with the user clicking the button and opens a 
 text window so you can edit the event handler.

The third step in developing an event-driven program is to write the main loop. This is a function
 that checks for the occurrence of events, and then calls the matching event handler to process it
 . Most event-driven programming environments already provide this main loop, so it need not be specifically 
 provided by the application programmer. RPG, an early programming language from IBM, whose 1960s design concept 
 was similar to event-driven programming discussed above, provided a built-in main I/O loop (known as the 
 "program cycle") where the calculations responded in accordance to 'indicators' (flags) that were set earlier
 in the cycle.
</p>
</div>
<hr/>
<Div id="low-level Programming Language">
<h1 style="color:Tomato;"><u><strong> About low-level Programming Language</strong></u></h1>
<p>A low-level programming language is a programming language that provides little or no abstraction from a
 computer's instruction set architecture—commands or functions in the language map closely to processor instructions. 
 Generally, this refers to either machine code or assembly language. Because of the low (hence the word) abstraction between 
 the language and machine language, low-level languages are sometimes described as being "close to the hardware". Programs 
 written in low-level languages tend to be relatively non-portable, due to being optimized for a certain type of system architecture.
Low-level languages can convert to machine code without a compiler or interpreter – second-generation programming languages 
use a simpler processor called an assembler – and the resulting code runs directly on the processor. A program written in
 a low-level language can be made to run very quickly, with a small memory footprint. An equivalent program in a high-level language
 can be less efficient and use more memory. Low-level languages are simple, but considered difficult to use, due to numerous technical details that
 the programmer must remember. By comparison, a high-level programming language isolates execution semantics of a computer architecture from 
 the specification of the program, which simplifies development.
</p>
</div>
<hr/>
<Div id="High-level Programming Language"> 
<h1 style="color:Tomato;"><u><strong> About High-level Programming Language</strong></u></h1>
<p>In computer science, a high-level programming language is a programming language with strong abstraction from the details of the computer. 
In contrast to low-level programming languages, it may use natural language elements, be easier to use, or may automate (or even hide entirely)
 significant areas of computing systems (e.g. memory management), making the process of developing a program simpler and more understandable
 than when using a lower-level language. The amount of abstraction provided defines how "high-level" a programming language is.
 In the 1960s, high-level programming languages using a compiler were commonly called autocodes. Examples of autocodes are COBOL and Fortran.
The first high-level programming language designed for computers was Plankalkül, created by Konrad Zuse.
 However, it was not implemented in his time, and his original contributions were largely isolated from other developments due to World War II,
 aside from the language's influence on the "Superplan" language by Heinz Rutishauser and also to some degree Algol. The first significantly 
 widespread high-level language was Fortran, a machine-independent development of IBM's earlier Autocode systems. Algol, defined in 1958 and 
 1960 by committees of European and American computer scientists, introduced recursion as well as nested functions under lexical scope.
 It was also the first language with a clear distinction between value and name-parameters and their corresponding semantics.
 Algol also introduced several structured programming concepts, such as the while-do and if-then-else constructs and its syntax
 was the first to be described in formal notation – "Backus–Naur form" (BNF). During roughly the same period, Cobol introduced
 records (also called structs) and Lisp introduced a fully general lambda abstraction in a programming language for the first time.
 "High-level language" refers to the higher level of abstraction from machine language. Rather than dealing with registers, 
 memory addresses and call stacks, high-level languages deal with variables, arrays, objects, complex arithmetic or boolean
 expressions, subroutines and functions, loops, threads, locks, and other abstract computer science concepts, with a focus 
 on usability over optimal program efficiency. Unlike low-level assembly languages, high-level languages have few, if any,
 language elements that translate directly into a machine's native opcodes. Other features, such as string handling routines,
 object-oriented language features, and file input/output, may also be present. One thing to note about high-level programming
 languages is that these languages allow the programmer to be detached and separated from the machine. That is, unlike low-level 
 languages like assembly or machine language, high-level programming can amplify the programmer's instructions and trigger a lot of data 
 movements in the background without their knowledge. The responsibility and power of executing instructions have been handed over to the
 machine from the programmer.
</p>
</div>
<hr/>
<Div id="Very High-level Programming Language">
<h1 style="color:Tomato;"><u><strong> About Very High-level Programming Language</strong></u></h1>
<p>A very high-level programming language (VHLL) is a programming language with a very high level of abstraction,
 used primarily as a professional programmer productivity tool.
 Very high-level programming languages are usually domain-specific languages, limited to a very specific application, purpose, 
 or type of task, and they are often scripting languages (especially extension languages), controlling a specific environment.
 For this reason, very high-level programming languages are often referred to as goal-oriented programming languages.[citation needed]
The term VHLL was used in the 1990s for what are today more often called high-level programming languages (not "very")
 used for scripting, such as Perl, Python, Ruby, and Visual Basic.
</p>
</div>

<button/> <A href="#top"> Return to the page TOP </button>

<!--Displaying Image-->
 <img src=""/>
</body>

</html>